#
# OpenSIPS residential configuration script
#     by OpenSIPS Solutions <team@opensips-solutions.com>
#
# This script was generated via "make menuconfig", from
#   the "Residential" scenario.
# You can enable / disable more features / functionalities by
#   re-generating the scenario with different options.#
#
# Please refer to the Core CookBook at:
#      https://opensips.org/Resources/DocsCookbooks
# for a explanation of possible statements, functions and parameters.
#


####### Global Parameters #########

/* uncomment the following lines to enable debugging */
#debug_mode=yes

log_level=3
stderror_enabled=no
stderror_level_filter=2
syslog_enabled=yes
syslog_facility=LOG_LOCAL0

udp_workers=2

/* uncomment the next line to enable the auto temporary blacklisting of
   not available destinations (default disabled) */
#disable_dns_blacklist=no

/* uncomment the next line to enable IPv6 lookup after IPv4 dns
   lookup failures (default disabled) */
#dns_try_ipv6=yes

socket=tls:0.0.0.0:6051
socket=wss:0.0.0.0:9443
socket=hep_udp:127.0.0.1:8887 use_workers 1

####### Modules Section ########

#set module path
mpath="/usr/lib/x86_64-linux-gnu/opensips/modules/"

#### SIGNALING module
loadmodule "signaling.so"

#### StateLess module
loadmodule "sl.so"

#### Transaction Module
loadmodule "tm.so"
modparam("tm", "fr_timeout", 5)
modparam("tm", "fr_inv_timeout", 30)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "onreply_avp_mode", 1)

#### Record Route Module
#loadmodule "rr.so"
/* do not append from tag to the RR (no need for this script) */
#modparam("rr", "append_fromtag", 0)

#### MAX ForWarD module
loadmodule "maxfwd.so"

#### SIP MSG OPerationS module
loadmodule "sipmsgops.so"

#### FIFO Management Interface
loadmodule "mi_fifo.so"
modparam("mi_fifo", "fifo_name", "/run/opensips/opensips_fifo")
modparam("mi_fifo", "fifo_mode", 0666)

#### Local cache
loadmodule "cachedb_local.so"
modparam("cachedb_local", "cachedb_url", "local://")

#### Tracer module to see the traffic over sngrep
loadmodule "proto_hep.so"
modparam("proto_hep", "hep_id", "[hep_dst] 127.0.0.1:8888; transport=udp; version=3")
loadmodule "tracer.so"
modparam("tracer", "trace_on", 1)
modparam("tracer", "trace_id", "[sngrep]uri=hep:hep_dst")

loadmodule "proto_tls.so"
modparam("proto_tls", "tls_port", 6051)
modparam("proto_tls", "tls_handshake_timeout", 3000)
modparam("proto_tls", "tls_send_timeout", 3000)
modparam("proto_tls", "tls_async_local_connect_timeout", 3000)
modparam("proto_tls", "tls_async_handshake_timeout", 3000)
# WebSocket part
loadmodule "proto_wss.so"
modparam("proto_wss", "wss_handshake_timeout", 3000)
modparam("proto_wss", "wss_tls_handshake_timeout", 3000)
modparam("proto_wss", "require_origin", no)

loadmodule "tls_openssl.so"
loadmodule "tls_mgm.so"

modparam("tls_mgm", "client_domain", "client")
modparam("tls_mgm", "certificate", "[client]/etc/ssl/certs/ssl-cert-snakeoil.pem")
modparam("tls_mgm", "private_key", "[client]/etc/ssl/private/ssl-cert-snakeoil.key")
modparam("tls_mgm", "ca_list", "[client]/etc/ssl/certs/ca-certificates.crt")
modparam("tls_mgm", "verify_cert", "[client]0")
modparam("tls_mgm", "require_cert", "[client]0")

modparam("tls_mgm", "server_domain", "server")
modparam("tls_mgm", "certificate", "[server]/etc/ssl/certs/ssl-cert-snakeoil.pem")
modparam("tls_mgm", "private_key", "[server]/etc/ssl/private/ssl-cert-snakeoil.key")
modparam("tls_mgm", "ca_list", "[server]/etc/ssl/certs/ca-certificates.crt")
modparam("tls_mgm", "verify_cert", "[server]0")
modparam("tls_mgm", "require_cert", "[server]0")

####### Routing Logic ########

# main request routing logic

route {

    trace("sngrep", "t", "sip");

    if (!mf_process_maxfwd_header(10)) {
        xlog("L_NOTICE", "[$rm][MAIN_ROUTE] Too Many Hops, discarding...\n");

        send_reply(483, "Too Many Hops");
        exit;
    }

    # $var(ct_uri) = $ct.fields(uri) + ";alias=" + $si + "~" + $sp + "~" + $socket_in(proto);
    # xlog("L_NOTICE", "Contact header: <$ct>\n URI transformations <$var(ct_uri)> => <$(var(ct_uri){uri.params})>\n");

    # if (has_totag()) {
    #
    #     # handle hop-by-hop ACK (no routing required)
    #     if (is_method("ACK") && t_check_trans()) {
    #         route(relay);
    #     }
    #
    #     # sequential request within a dialog should
    #     # take the path determined by record-routing
    #     if ( !loose_route() ) {
    #         # we do record-routing for all our traffic, so we should not
    #         # receive any sequential requests without Route hdr.
    #         send_reply(404, "Not here");
    #         exit;
    #     }
    #
    #     # route it out to whatever destination was set by loose_route()
    #     # in $du (destination URI).
    #     route(relay);
    # }

    # absorb retransmissions, but do not create transaction
    t_check_trans();

    # record routing
    #remove_hf("Route");
    #if (!is_method("REGISTER|MESSAGE")) {
    #    record_route();
    #}

    # Adding rcv parameter to Contact header
    # add_rcv_param(1);

    route(relay);
}

route[set_destination] {

    route(handle_ruri_alias);

    if ($socket_in(proto) == "tls") {
        # We got connection from TLS, route it to WebSocket and save source of the message

        ruri_del_param("transport");
        ruri_add_param("transport=wss");

        $socket_out = "wss:0.0.0.0:9443";

        $var(source_uri) = "sip:" + $si + ":" + $sp;

        xlog("L_NOTICE", "[$rm][SET_DESTINATION][TLS] Got $rm from <$var(source_uri)> over TLS, sending to <$ru> over WebSocket...\n");

        # Knowing that we are using vp_acc as contact alias for voip_patrol account - use this information
        $var(vp_acc) = $(ct.fields(uri){uri.param,vp_acc});
        if ($var(vp_acc) != NULL && $var(vp_acc) != "") {
            cache_store("local", "$var(vp_acc)", $var(source_uri));

            xlog("L_NOTICE", "[$rm][SET_DESTINATION][TLS] Saved source <$var(source_uri)> based on Contact vp_acc=<$var(vp_acc)>\n");
        }

        cache_store("local", "$ci", $var(source_uri));
        cache_store("local", "last_tls", $var(source_uri));

        return;
    }

    # We got a connection from WebSocket.

    ruri_del_param("transport");
    ruri_add_param("transport=tls");

    $socket_out = "tls:0.0.0.0:6051";

    xlog("L_NOTICE", "[$rm][SET_DESTINATION][WSS] Got message over WebSocker, sending to TLS...\n");

    if ($du != NULL) {
        # Should never get here
        xlog("L_NOTICE", "[$rm][SET_DESTINATION][WSS] Explicit routing to <$du>. Error?\n");

        return;
    }

    $du = "sip:127.0.0.1:5061";

    $var(vp_acc) = $(ru{uri.param,vp_acc});
    if ($var(vp_acc) != NULL && $var(vp_acc) != "" && cache_fetch("local", "$var(vp_acc)", $var(du))) {
        xlog("L_NOTICE", "[$rm][SET_DESTINATION][WSS] Set destination <$du> based on the vp_acc = <$var(vp_acc)>\n");

        $du = $var(du);
        return;
    }

    if (cache_fetch("local", "$ci", $var(du))) {
        xlog("L_NOTICE", "[$rm][SET_DESTINATION][WSS] Set destination <$du> based on the CallID = <$ci>\n");

        $du = $var(du);
        return;
    }

    if (cache_fetch("local", "last_tls", $var(du))) {
        xlog("L_NOTICE", "[$rm][SET_DESTINATION][WSS] Set destination <$du> based on the last seen TLS connection\n");

        $du = $var(du);
        return;
    }

    xlog("L_NOTICE", "[$rm][SET_DESTINATION][WSS] Set destination <$du> based on the default value\n");
}

route[handle_ruri_alias] {
    xlog("L_NOTICE", "[$rm][HANDLE_RURI_ALIAS] Got RURI: <$ru> / <$(ru{uri.params})> \n");
}

route[relay] {
    route(set_destination);

    if (!t_relay()) {
        xlog("L_NOTICE", "[$rm][RELAY] Relay to <$du>/<$ru> failed.\n");

        send_reply(500, "Internal Error");
    }
    exit;
}

onreply_route {
    $var(ct_params) = ";original=" + $ct.fields(uri) + ";alias=" + $si + "~" + $sp + "~" + $socket_in(proto);

    if (is_method("INVITE") && $rs == 200) {
        # Make sure subsequent ACK's will be sent in correct way
        if ($socket_in(proto) == "wss") {
            # Need to set TLS interface as a contact field
            $var(updated_contact) = "sip:127.0.0.1:6051;transport=tls";
            $var(new_contact) = $var(updated_contact) + $var(ct_params);

            xlog("L_NOTICE", "[$rm][REPLY][$rs] received a reply: <$ct> -> <$var(new_contact)>\n");
        } else {
            # Need to set WSS interface as a contact field
            $var(updated_contact) = "sip:127.0.0.1:9443;transport=wss";
            $var(new_contact) = $var(updated_contact) + $var(ct_params);

            xlog("L_NOTICE", "[$rm][REPLY][$rs] received a reply: <$ct> -> <$var(new_contact)>\n");
        }
    }
}
